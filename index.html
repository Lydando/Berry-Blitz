import { useEffect, useRef, useState } from 'react';
import GameCanvas from './GameCanvas';
import GameUI from './GameUI';
import { useGameState } from '../lib/stores/useGameState';
import { GameEngine } from '../lib/gameEngine';
import { TouchControls } from '../lib/touchControls';
import { useAudio } from '../lib/stores/useAudio';

interface GameProps {
  onGameEnd: () => void;
}

const Game: React.FC<GameProps> = ({ onGameEnd }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const gameEngineRef = useRef<GameEngine | null>(null);
  const touchControlsRef = useRef<TouchControls | null>(null);
  const animationRef = useRef<number>();
  const isPausedRef = useRef(false);
  
  const { 
    gameState, 
    score, 
    survivalTime, 
    isGameOver, 
    resetGame,
    updateHighScore,
    updateBestTime 
  } = useGameState();
  
  const { backgroundMusic, isMuted, toggleMute } = useAudio();
  const [isPaused, setIsPaused] = useState(false);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Initialize game engine only once
    const gameEngine = new GameEngine(canvas);
    gameEngineRef.current = gameEngine;

    // Initialize touch controls only once
    const touchControls = new TouchControls(canvas);
    touchControlsRef.current = touchControls;

    console.log('GameEngine and TouchControls initialized');

    return () => {
      console.log('Cleaning up GameEngine');
    };
  }, []); // Empty dependency array - initialize only once

  useEffect(() => {
    // Update pause ref when state changes
    isPausedRef.current = isPaused;
    
    // Handle background music separately
    if (backgroundMusic && !isMuted && !isPaused) {
      backgroundMusic.play().catch(console.log);
    } else if (backgroundMusic) {
      backgroundMusic.pause();
    }
  }, [backgroundMusic, isMuted, isPaused]);

  useEffect(() => {
    if (!gameEngineRef.current || !touchControlsRef.current) return;
    
    // Game loop - runs only once, never recreated
    let lastTime = performance.now();
    let hasEnded = false;
    
    const gameLoop = (currentTime: number) => {
      // Cap deltaTime to prevent huge jumps
      const deltaTime = Math.min(currentTime - lastTime, 100);
      lastTime = currentTime;

      const currentGameState = useGameState.getState();
      const currentIsGameOver = currentGameState.isGameOver;
      const currentIsPaused = isPausedRef.current;
      
      if (!currentIsPaused && !currentIsGameOver && gameEngineRef.current && touchControlsRef.current) {
        const direction = touchControlsRef.current.getDirection();
        gameEngineRef.current.update(deltaTime, direction);
        gameEngineRef.current.render();
      }

      if (!currentIsGameOver) {
        animationRef.current = requestAnimationFrame(gameLoop);
      } else if (!hasEnded) {
        // Game ended - update statistics only once
        hasEnded = true;
        updateHighScore(currentGameState.score);
        updateBestTime(currentGameState.survivalTime);
        
        // Stop background music
        if (backgroundMusic) {
          backgroundMusic.pause();
          backgroundMusic.currentTime = 0;
        }
      }
    };

    animationRef.current = requestAnimationFrame(gameLoop);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []); // Only run once!

  const handleRestart = () => {
    resetGame();
    if (gameEngineRef.current) {
      gameEngineRef.current.reset();
    }
    if (backgroundMusic && !isMuted) {
      backgroundMusic.currentTime = 0;
      backgroundMusic.play().catch(console.log);
    }
  };

  const handlePause = () => {
    setIsPaused(!isPaused);
    if (backgroundMusic) {
      if (isPaused) {
        backgroundMusic.play().catch(console.log);
      } else {
        backgroundMusic.pause();
      }
    }
  };

  return (
    <div className="game-container">
      <GameCanvas 
        ref={canvasRef}
        gameEngine={gameEngineRef.current}
      />
      
      <GameUI
        score={score}
        survivalTime={survivalTime}
        isGameOver={isGameOver}
        isPaused={isPaused}
        isMuted={isMuted}
        onRestart={handleRestart}
        onPause={handlePause}
        onMute={toggleMute}
        onQuit={onGameEnd}
        powerUps={gameEngineRef.current?.getPowerUpStatus() || {}}
      />
    </div>
  );
};

export default Game;
